# Rust FFI — CYBFFmpeg

This document describes the Rust-Swift interop layer using C FFI.

## Architecture

```text
Swift (Public API)
      ↓
Swift (RustBridge)
      ↓
C Header (cyb_ffmpeg.h)
      ↓
Rust FFI (#[no_mangle])
      ↓
Rust Core (safe Rust)
```

## C Header Generation

Headers are generated automatically by `cbindgen`:

```bash
cd cyb-ffmpeg-core
cbindgen --config cbindgen.toml --crate cyb-ffmpeg-core --output ../Sources/CYBFFmpeg/CybFFmpegC/include/cyb_ffmpeg.h
```

### cbindgen.toml

```toml
language = "C"
header = "// Auto-generated by cbindgen. Do not edit."
include_guard = "CYB_FFMPEG_H"
autogen_warning = "/* Warning: this file is autogenerated by cbindgen. Don't modify this manually. */"

[export]
prefix = "Cyb"

[enum]
prefix_with_name = true

[fn]
prefix = "cyb_"
```

## FFI Types

### Result Type

```c
typedef enum CybResult {
    CybResult_Success = 0,
    CybResult_ErrorFileNotFound = 1,
    CybResult_ErrorInvalidFormat = 2,
    CybResult_ErrorCodecNotSupported = 3,
    CybResult_ErrorDecodeFailed = 4,
    CybResult_ErrorSeekFailed = 5,
    CybResult_ErrorMemory = 6,
    CybResult_ErrorInvalidHandle = 7,
    CybResult_ErrorUnknown = 99,
} CybResult;
```

### Handle Type

```c
// Opaque pointer to Rust decoder
typedef struct CybDecoderHandle CybDecoderHandle;
```

### Media Info

```c
typedef struct CybMediaInfo {
    double duration;
    const char* container_format;
    uint32_t video_track_count;
    uint32_t audio_track_count;
    CybVideoTrack* video_tracks;
    CybAudioTrack* audio_tracks;
} CybMediaInfo;

typedef struct CybVideoTrack {
    int32_t index;
    const char* codec_name;
    const char* codec_long_name;
    int32_t width;
    int32_t height;
    double frame_rate;
    int64_t bit_rate;
    const char* pixel_format;
    bool is_hardware_decodable;
} CybVideoTrack;

typedef struct CybAudioTrack {
    int32_t index;
    const char* codec_name;
    const char* codec_long_name;
    int32_t sample_rate;
    int32_t channels;
    const char* channel_layout;
    int64_t bit_rate;
    const char* language_code;
} CybAudioTrack;
```

### Frame Type

```c
typedef struct CybVideoFrame {
    void* pixel_data;           // Pointer to pixel buffer
    uint32_t width;
    uint32_t height;
    uint32_t stride;
    int64_t pts_microseconds;
    int64_t duration_microseconds;
    bool is_keyframe;
    int64_t frame_number;
    CybPixelFormat pixel_format;
} CybVideoFrame;

typedef enum CybPixelFormat {
    CybPixelFormat_BGRA,
    CybPixelFormat_NV12,
    CybPixelFormat_YUV420P,
} CybPixelFormat;
```

### Cache Statistics

```c
typedef struct CybCacheStats {
    uint32_t l1_entries;
    uint32_t l2_entries;
    uint32_t l3_entries;
    uint64_t l1_hit_count;
    uint64_t l2_hit_count;
    uint64_t l3_hit_count;
    uint64_t miss_count;
    uint64_t memory_usage_bytes;
} CybCacheStats;
```

### Configuration

```c
typedef struct CybDecoderConfig {
    bool prefer_hardware_decoding;
    uint32_t l1_cache_capacity;
    uint32_t l2_cache_capacity;
    uint32_t l3_cache_capacity;
    bool enable_prefetch;
    uint32_t thread_count;
    CybPixelFormat output_pixel_format;
} CybDecoderConfig;
```

## FFI Functions

### Decoder Lifecycle

```c
// Create decoder
CybDecoderHandle* cyb_decoder_create(
    const char* path,
    const CybDecoderConfig* config
);

// Prepare decoder (loads metadata)
CybResult cyb_decoder_prepare(CybDecoderHandle* handle);

// Destroy decoder
void cyb_decoder_destroy(CybDecoderHandle* handle);

// Get last error message
const char* cyb_get_last_error(void);
```

### Media Information

```c
// Get media info (after prepare)
CybResult cyb_decoder_get_media_info(
    CybDecoderHandle* handle,
    CybMediaInfo* out_info
);

// Free media info strings
void cyb_media_info_free(CybMediaInfo* info);
```

### Frame Access

```c
// Get frame at specific time
CybResult cyb_decoder_get_frame_at(
    CybDecoderHandle* handle,
    int64_t time_microseconds,
    int64_t tolerance_microseconds,
    CybVideoFrame* out_frame
);

// Get next frame
CybResult cyb_decoder_get_next_frame(
    CybDecoderHandle* handle,
    CybVideoFrame* out_frame
);

// Seek to time
CybResult cyb_decoder_seek(
    CybDecoderHandle* handle,
    int64_t time_microseconds
);

// Release frame resources
void cyb_frame_release(CybVideoFrame* frame);
```

### Decoding Control

```c
// Start decoding
CybResult cyb_decoder_start(CybDecoderHandle* handle);

// Stop decoding
CybResult cyb_decoder_stop(CybDecoderHandle* handle);
```

### Prefetch

```c
// Start prefetch for scrubbing
CybResult cyb_decoder_start_prefetch(
    CybDecoderHandle* handle,
    int32_t direction,      // 1 = forward, -1 = backward
    double velocity         // Speed multiplier
);

// Stop prefetch
CybResult cyb_decoder_stop_prefetch(CybDecoderHandle* handle);
```

### Cache Statistics

```c
// Get cache statistics
void cyb_decoder_get_cache_stats(
    CybDecoderHandle* handle,
    CybCacheStats* out_stats
);
```

## Swift Bridge Implementation

### RustBridge.swift

```swift
import CybFFmpegC

internal final class RustBridge {
    private let handle: OpaquePointer

    init(path: String, configuration: DecoderConfiguration) throws {
        var config = CybDecoderConfig(
            prefer_hardware_decoding: configuration.preferHardwareDecoding,
            l1_cache_capacity: UInt32(configuration.cacheConfiguration.l1Capacity),
            l2_cache_capacity: UInt32(configuration.cacheConfiguration.l2Capacity),
            l3_cache_capacity: UInt32(configuration.cacheConfiguration.l3Capacity),
            enable_prefetch: configuration.cacheConfiguration.enablePrefetch,
            thread_count: UInt32(configuration.threadCount),
            output_pixel_format: configuration.outputPixelFormat.toCyb()
        )

        guard let handle = cyb_decoder_create(path, &config) else {
            throw FFmpegError.memoryError
        }
        self.handle = handle
    }

    func prepare() throws {
        let result = cyb_decoder_prepare(handle)
        try checkResult(result)
    }

    func getFrame(at time: Double, tolerance: Double) throws -> FFmpegFrame? {
        let timeMicros = Int64(time * 1_000_000)
        let toleranceMicros = Int64(tolerance * 1_000_000)

        var frame = CybVideoFrame()
        let result = cyb_decoder_get_frame_at(handle, timeMicros, toleranceMicros, &frame)

        if result == CybResult_Success {
            defer { cyb_frame_release(&frame) }
            return try convertFrame(frame)
        } else if result == CybResult_ErrorSeekFailed {
            return nil
        } else {
            throw convertError(result)
        }
    }

    deinit {
        cyb_decoder_destroy(handle)
    }

    // MARK: - Private Helpers

    private func checkResult(_ result: CybResult) throws {
        guard result == CybResult_Success else {
            throw convertError(result)
        }
    }

    private func convertError(_ result: CybResult) -> FFmpegError {
        switch result {
        case CybResult_ErrorFileNotFound:
            return .fileNotFound(URL(fileURLWithPath: ""))
        case CybResult_ErrorInvalidFormat:
            return .invalidFormat(getLastError())
        case CybResult_ErrorCodecNotSupported:
            return .codecNotSupported(getLastError())
        case CybResult_ErrorDecodeFailed:
            return .decodeFailed(getLastError())
        case CybResult_ErrorSeekFailed:
            return .seekFailed(0)
        case CybResult_ErrorMemory:
            return .memoryError
        default:
            return .unknown(result.rawValue)
        }
    }

    private func getLastError() -> String {
        if let cStr = cyb_get_last_error() {
            return String(cString: cStr)
        }
        return "Unknown error"
    }

    private func convertFrame(_ cybFrame: CybVideoFrame) throws -> FFmpegFrame {
        // Convert to CVPixelBuffer
        let pixelBuffer = try PixelBufferConverter.convert(
            data: cybFrame.pixel_data,
            width: Int(cybFrame.width),
            height: Int(cybFrame.height),
            stride: Int(cybFrame.stride),
            format: PixelFormat(cybFrame.pixel_format)
        )

        return FFmpegFrame(
            pixelBuffer: pixelBuffer,
            presentationTime: Double(cybFrame.pts_microseconds) / 1_000_000,
            duration: Double(cybFrame.duration_microseconds) / 1_000_000,
            isKeyframe: cybFrame.is_keyframe,
            width: Int(cybFrame.width),
            height: Int(cybFrame.height),
            frameNumber: cybFrame.frame_number
        )
    }
}
```

## Rust Implementation

### FFI Exports

```rust
// src/ffi/mod.rs

use std::ffi::{CStr, CString};
use std::os::raw::c_char;
use std::ptr;

use crate::decoder::Decoder;
use crate::error::Error;

thread_local! {
    static LAST_ERROR: std::cell::RefCell<Option<CString>> = std::cell::RefCell::new(None);
}

fn set_last_error(msg: &str) {
    LAST_ERROR.with(|e| {
        *e.borrow_mut() = CString::new(msg).ok();
    });
}

#[no_mangle]
pub extern "C" fn cyb_get_last_error() -> *const c_char {
    LAST_ERROR.with(|e| {
        e.borrow()
            .as_ref()
            .map(|s| s.as_ptr())
            .unwrap_or(ptr::null())
    })
}

#[no_mangle]
pub extern "C" fn cyb_decoder_create(
    path: *const c_char,
    config: *const CybDecoderConfig,
) -> *mut CybDecoderHandle {
    let path = unsafe {
        if path.is_null() {
            set_last_error("Path is null");
            return ptr::null_mut();
        }
        match CStr::from_ptr(path).to_str() {
            Ok(s) => s,
            Err(_) => {
                set_last_error("Invalid UTF-8 in path");
                return ptr::null_mut();
            }
        }
    };

    let config = unsafe {
        if config.is_null() {
            DecoderConfig::default()
        } else {
            DecoderConfig::from_c(&*config)
        }
    };

    match Decoder::new(path, config) {
        Ok(decoder) => Box::into_raw(Box::new(CybDecoderHandle { decoder })),
        Err(e) => {
            set_last_error(&e.to_string());
            ptr::null_mut()
        }
    }
}

#[no_mangle]
pub extern "C" fn cyb_decoder_destroy(handle: *mut CybDecoderHandle) {
    if !handle.is_null() {
        unsafe {
            drop(Box::from_raw(handle));
        }
    }
}

#[no_mangle]
pub extern "C" fn cyb_decoder_prepare(handle: *mut CybDecoderHandle) -> CybResult {
    let decoder = unsafe {
        if handle.is_null() {
            return CybResult::ErrorInvalidHandle;
        }
        &mut (*handle).decoder
    };

    match decoder.prepare() {
        Ok(()) => CybResult::Success,
        Err(e) => {
            set_last_error(&e.to_string());
            e.into()
        }
    }
}
```

### Handle Structure

```rust
// Opaque handle wrapping the actual decoder
pub struct CybDecoderHandle {
    decoder: Decoder,
}

// Prevent Send/Sync to ensure thread safety
impl !Send for CybDecoderHandle {}
impl !Sync for CybDecoderHandle {}
```

## Memory Management

### Ownership Rules

1. **Handles**: Swift owns, Rust manages internal state
2. **Strings**: Rust allocates, Swift must not free
3. **Frames**: Rust allocates, Swift must call `cyb_frame_release`
4. **Info structs**: Copy on read, call `cyb_*_free` for nested allocations

### String Handling

```rust
// Rust side: Return pointer to internal string
#[no_mangle]
pub extern "C" fn cyb_get_codec_name(handle: *const CybDecoderHandle) -> *const c_char {
    // Return pointer to internally owned CString
    // Valid until decoder is destroyed
}

// Swift side: Copy immediately if needed
let codecName = String(cString: cyb_get_codec_name(handle))
```

### Frame Memory

```rust
#[no_mangle]
pub extern "C" fn cyb_frame_release(frame: *mut CybVideoFrame) {
    if frame.is_null() {
        return;
    }

    unsafe {
        let frame = &mut *frame;
        if !frame.pixel_data.is_null() {
            // Free pixel buffer
            Vec::from_raw_parts(
                frame.pixel_data as *mut u8,
                frame.stride as usize * frame.height as usize,
                frame.stride as usize * frame.height as usize,
            );
        }
        frame.pixel_data = ptr::null_mut();
    }
}
```

## Error Handling

### Error Conversion

```rust
impl From<Error> for CybResult {
    fn from(e: Error) -> Self {
        match e {
            Error::FileNotFound(_) => CybResult::ErrorFileNotFound,
            Error::InvalidFormat(_) => CybResult::ErrorInvalidFormat,
            Error::CodecNotSupported(_) => CybResult::ErrorCodecNotSupported,
            Error::DecodeFailed(_) => CybResult::ErrorDecodeFailed,
            Error::SeekFailed(_) => CybResult::ErrorSeekFailed,
            Error::Memory => CybResult::ErrorMemory,
            _ => CybResult::ErrorUnknown,
        }
    }
}
```

### Thread-Local Error Storage

```rust
// Store detailed error message in thread-local storage
fn set_last_error(msg: &str) {
    LAST_ERROR.with(|e| {
        *e.borrow_mut() = CString::new(msg).ok();
    });
}

// Swift can retrieve via cyb_get_last_error()
```

## Thread Safety

### Guidelines

1. **One handle per thread**: Don't share handles across threads
2. **Swift actor isolation**: Use Swift actors for thread safety
3. **Rust internal threading**: Prefetch uses internal threads safely

### Swift Actor Pattern

```swift
actor FFmpegDecoderActor {
    private var bridge: RustBridge?

    func prepare(url: URL) async throws {
        bridge = try RustBridge(path: url.path, configuration: .default)
        try bridge?.prepare()
    }

    func getFrame(at time: Double) throws -> FFmpegFrame? {
        try bridge?.getFrame(at: time, tolerance: 0.016)
    }
}
```

## Build Configuration

### Build Script (build.rs)

```rust
fn main() {
    // Link to FFmpeg
    println!("cargo:rustc-link-lib=avcodec");
    println!("cargo:rustc-link-lib=avformat");
    println!("cargo:rustc-link-lib=avutil");
    println!("cargo:rustc-link-lib=swscale");

    // Link to VideoToolbox (macOS)
    #[cfg(target_os = "macos")]
    {
        println!("cargo:rustc-link-lib=framework=VideoToolbox");
        println!("cargo:rustc-link-lib=framework=CoreMedia");
        println!("cargo:rustc-link-lib=framework=CoreVideo");
    }

    // Generate C header
    let crate_dir = std::env::var("CARGO_MANIFEST_DIR").unwrap();
    cbindgen::Builder::new()
        .with_crate(&crate_dir)
        .with_config(cbindgen::Config::from_file("cbindgen.toml").unwrap())
        .generate()
        .expect("Unable to generate bindings")
        .write_to_file("../Sources/CYBFFmpeg/CybFFmpegC/include/cyb_ffmpeg.h");
}
```
